{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","processBackgroundImage","_slicedToArray2","processColor","DIRECTION_REGEX","ANGLE_UNIT_REGEX","TO_BOTTOM_START_END_POINTS","start","x","y","end","backgroundImage","result","parseCSSLinearGradient","replace","Array","isArray","bgImage","processedColorStops","index","colorStops","length","colorStop","processedColor","color","positions","position","endsWith","push","parseFloat","points","direction","test","angle","parseAngle","calculateStartEndPointsFromAngle","processedPoints","calculateStartEndPointsFromDirection","fixedColorStops","getFixedColorStops","concat","type","cssString","gradients","match","linearGradientRegex","exec","gradientContent","parts","split","trimmedDirection","trim","toLowerCase","colorStopRegex","shift","parsedPoints","lastIndex","fullColorStopsStr","join","colorStopMatch","_colorStopMatch","_colorStopMatch2","position1","position2","normalizedDirection","angleRadians","angleRadiansNormalized","Math","PI","endX","sin","endY","cos","startX","startY","_match","unit","numericValue","_colorStops$0$positio","hasNullPositions","maxPositionSoFar","i","newPosition","max","lastDefinedIndex","undefined","unpositionedStops","startPosition","endPosition","increment","j"],"sources":["processBackgroundImage.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n'use strict';\n\nimport type {ProcessedColorValue} from './processColor';\nimport type {GradientValue} from './StyleSheetTypes';\n\nconst processColor = require('./processColor').default;\nconst DIRECTION_REGEX =\n  /^to\\s+(?:top|bottom|left|right)(?:\\s+(?:top|bottom|left|right))?/;\nconst ANGLE_UNIT_REGEX = /^([+-]?\\d*\\.?\\d+)(deg|grad|rad|turn)$/i;\n\nconst TO_BOTTOM_START_END_POINTS = {\n  start: {x: 0.5, y: 0},\n  end: {x: 0.5, y: 1},\n};\n\ntype ParsedGradientValue = {\n  type: 'linearGradient',\n  start: {x: number, y: number},\n  end: {x: number, y: number},\n  colorStops: $ReadOnlyArray<{\n    color: ProcessedColorValue,\n    position: number,\n  }>,\n};\n\nexport default function processBackgroundImage(\n  backgroundImage: ?($ReadOnlyArray<GradientValue> | string),\n): $ReadOnlyArray<ParsedGradientValue> {\n  let result: $ReadOnlyArray<ParsedGradientValue> = [];\n  if (backgroundImage == null) {\n    return result;\n  }\n\n  if (typeof backgroundImage === 'string') {\n    result = parseCSSLinearGradient(backgroundImage.replace(/\\n/g, ' '));\n  } else if (Array.isArray(backgroundImage)) {\n    for (const bgImage of backgroundImage) {\n      const processedColorStops: Array<{\n        color: ProcessedColorValue,\n        position: number | null,\n      }> = [];\n      for (let index = 0; index < bgImage.colorStops.length; index++) {\n        const colorStop = bgImage.colorStops[index];\n        const processedColor = processColor(colorStop.color);\n        if (processedColor == null) {\n          // If a color is invalid, return an empty array and do not apply gradient. Same as web.\n          return [];\n        }\n        if (colorStop.positions != null && colorStop.positions.length > 0) {\n          for (const position of colorStop.positions) {\n            if (position.endsWith('%')) {\n              processedColorStops.push({\n                color: processedColor,\n                position: parseFloat(position) / 100,\n              });\n            } else {\n              // If a position is invalid, return an empty array and do not apply gradient. Same as web.\n              return [];\n            }\n          }\n        } else {\n          processedColorStops.push({\n            color: processedColor,\n            position: null,\n          });\n        }\n      }\n\n      let points: {\n        start: ParsedGradientValue['start'],\n        end: ParsedGradientValue['end'],\n      } | null = null;\n\n      if (typeof bgImage.direction === 'undefined') {\n        points = TO_BOTTOM_START_END_POINTS;\n      } else if (ANGLE_UNIT_REGEX.test(bgImage.direction)) {\n        const angle = parseAngle(bgImage.direction);\n        if (angle != null) {\n          points = calculateStartEndPointsFromAngle(angle);\n        }\n      } else if (DIRECTION_REGEX.test(bgImage.direction)) {\n        const processedPoints = calculateStartEndPointsFromDirection(\n          bgImage.direction,\n        );\n        if (processedPoints != null) {\n          points = processedPoints;\n        }\n      }\n\n      const fixedColorStops = getFixedColorStops(processedColorStops);\n\n      if (points != null) {\n        result = result.concat({\n          type: 'linearGradient',\n          start: points.start,\n          end: points.end,\n          colorStops: fixedColorStops,\n        });\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction parseCSSLinearGradient(\n  cssString: string,\n): $ReadOnlyArray<ParsedGradientValue> {\n  const gradients = [];\n  let match;\n  const linearGradientRegex = /linear-gradient\\s*\\(((?:\\([^)]*\\)|[^())])*)\\)/gi;\n\n  while ((match = linearGradientRegex.exec(cssString))) {\n    const gradientContent = match[1];\n    const parts = gradientContent.split(',');\n    let points = TO_BOTTOM_START_END_POINTS;\n    const trimmedDirection = parts[0].trim().toLowerCase();\n    const colorStopRegex =\n      /\\s*((?:(?:rgba?|hsla?)\\s*\\([^)]+\\))|#[0-9a-fA-F]+|[a-zA-Z]+)(?:\\s+(-?[0-9.]+%?)(?:\\s+(-?[0-9.]+%?))?)?\\s*/gi;\n\n    if (ANGLE_UNIT_REGEX.test(trimmedDirection)) {\n      const angle = parseAngle(trimmedDirection);\n      if (angle != null) {\n        points = calculateStartEndPointsFromAngle(angle);\n        parts.shift();\n      } else {\n        // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n    } else if (DIRECTION_REGEX.test(trimmedDirection)) {\n      const parsedPoints =\n        calculateStartEndPointsFromDirection(trimmedDirection);\n      if (parsedPoints != null) {\n        points = parsedPoints;\n        parts.shift();\n      } else {\n        // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n    } else if (!colorStopRegex.test(trimmedDirection)) {\n      // If first part is not an angle/direction or a color stop, return an empty array and do not apply any gradient. Same as web.\n      return [];\n    }\n    colorStopRegex.lastIndex = 0;\n\n    const colorStops = [];\n    const fullColorStopsStr = parts.join(',');\n    let colorStopMatch;\n    while ((colorStopMatch = colorStopRegex.exec(fullColorStopsStr))) {\n      const [, color, position1, position2] = colorStopMatch;\n      const processedColor = processColor(color.trim().toLowerCase());\n      if (processedColor == null) {\n        // If a color is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n\n      if (typeof position1 !== 'undefined') {\n        if (position1.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position1) / 100,\n          });\n        } else {\n          // If a position is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      } else {\n        colorStops.push({\n          color: processedColor,\n          position: null,\n        });\n      }\n\n      if (typeof position2 !== 'undefined') {\n        if (position2.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position2) / 100,\n          });\n        } else {\n          // If a position is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      }\n    }\n\n    const fixedColorStops = getFixedColorStops(colorStops);\n\n    gradients.push({\n      type: 'linearGradient',\n      start: points.start,\n      end: points.end,\n      colorStops: fixedColorStops,\n    });\n  }\n\n  return gradients;\n}\n\nfunction calculateStartEndPointsFromDirection(direction: string): ?{\n  start: {x: number, y: number},\n  end: {x: number, y: number},\n} {\n  // Remove extra whitespace\n  const normalizedDirection = direction.replace(/\\s+/g, ' ');\n\n  switch (normalizedDirection) {\n    case 'to right':\n      return {\n        start: {x: 0, y: 0.5},\n        end: {x: 1, y: 0.5},\n      };\n    case 'to left':\n      return {\n        start: {x: 1, y: 0.5},\n        end: {x: 0, y: 0.5},\n      };\n    case 'to bottom':\n      return TO_BOTTOM_START_END_POINTS;\n    case 'to top':\n      return {\n        start: {x: 0.5, y: 1},\n        end: {x: 0.5, y: 0},\n      };\n    case 'to bottom right':\n    case 'to right bottom':\n      return {\n        start: {x: 0, y: 0},\n        end: {x: 1, y: 1},\n      };\n    case 'to top left':\n    case 'to left top':\n      return {\n        start: {x: 1, y: 1},\n        end: {x: 0, y: 0},\n      };\n    case 'to bottom left':\n    case 'to left bottom':\n      return {\n        start: {x: 1, y: 0},\n        end: {x: 0, y: 1},\n      };\n    case 'to top right':\n    case 'to right top':\n      return {\n        start: {x: 0, y: 1},\n        end: {x: 1, y: 0},\n      };\n    default:\n      return null;\n  }\n}\n\nfunction calculateStartEndPointsFromAngle(angleRadians: number): {\n  start: {x: number, y: number},\n  end: {x: number, y: number},\n} {\n  // Normalize angle to be between 0 and 2Ï€\n  let angleRadiansNormalized = angleRadians % (2 * Math.PI);\n  if (angleRadiansNormalized < 0) {\n    angleRadiansNormalized += 2 * Math.PI;\n  }\n\n  const endX = 0.5 + 0.5 * Math.sin(angleRadiansNormalized);\n  const endY = 0.5 - 0.5 * Math.cos(angleRadiansNormalized);\n\n  const startX = 1 - endX;\n  const startY = 1 - endY;\n\n  return {\n    start: {x: startX, y: startY},\n    end: {x: endX, y: endY},\n  };\n}\n\nfunction parseAngle(angle: string): ?number {\n  const match = angle.match(ANGLE_UNIT_REGEX);\n  if (!match) {\n    return null;\n  }\n\n  const [, value, unit] = match;\n\n  const numericValue = parseFloat(value);\n  switch (unit) {\n    case 'deg':\n      return (numericValue * Math.PI) / 180;\n    case 'grad':\n      return (numericValue * Math.PI) / 200;\n    case 'rad':\n      return numericValue;\n    case 'turn':\n      return numericValue * 2 * Math.PI;\n    default:\n      return null;\n  }\n}\n\n// https://drafts.csswg.org/css-images-4/#color-stop-fixup\nfunction getFixedColorStops(\n  colorStops: $ReadOnlyArray<{\n    color: ProcessedColorValue,\n    position: number | null,\n  }>,\n): Array<{\n  color: ProcessedColorValue,\n  position: number,\n}> {\n  let fixedColorStops: Array<{\n    color: ProcessedColorValue,\n    position: number,\n  }> = [];\n  let hasNullPositions = false;\n  let maxPositionSoFar = colorStops[0].position ?? 0;\n  for (let i = 0; i < colorStops.length; i++) {\n    const colorStop = colorStops[i];\n    let newPosition = colorStop.position;\n    if (newPosition === null) {\n      // Step 1:\n      // If the first color stop does not have a position,\n      // set its position to 0%. If the last color stop does not have a position,\n      // set its position to 100%.\n      if (i === 0) {\n        newPosition = 0;\n      } else if (i === colorStops.length - 1) {\n        newPosition = 1;\n      }\n    }\n    // Step 2:\n    // If a color stop or transition hint has a position\n    // that is less than the specified position of any color stop or transition hint\n    // before it in the list, set its position to be equal to the\n    // largest specified position of any color stop or transition hint before it.\n    if (newPosition !== null) {\n      newPosition = Math.max(newPosition, maxPositionSoFar);\n      fixedColorStops[i] = {\n        color: colorStop.color,\n        position: newPosition,\n      };\n      maxPositionSoFar = newPosition;\n    } else {\n      hasNullPositions = true;\n    }\n  }\n\n  // Step 3:\n  // If any color stop still does not have a position,\n  // then, for each run of adjacent color stops without positions,\n  // set their positions so that they are evenly spaced between the preceding and\n  // following color stops with positions.\n  if (hasNullPositions) {\n    let lastDefinedIndex = 0;\n    for (let i = 1; i < fixedColorStops.length; i++) {\n      if (fixedColorStops[i] !== undefined) {\n        const unpositionedStops = i - lastDefinedIndex - 1;\n        if (unpositionedStops > 0) {\n          const startPosition = fixedColorStops[lastDefinedIndex].position;\n          const endPosition = fixedColorStops[i].position;\n          const increment =\n            (endPosition - startPosition) / (unpositionedStops + 1);\n          for (let j = 1; j <= unpositionedStops; j++) {\n            fixedColorStops[lastDefinedIndex + j] = {\n              color: colorStops[lastDefinedIndex + j].color,\n              position: startPosition + increment * j,\n            };\n          }\n        }\n        lastDefinedIndex = i;\n      }\n    }\n  }\n\n  return fixedColorStops;\n}\n"],"mappings":"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","ignoreList":[]}